\section{Results and Discussion} \label{sec:results}

\input{fig/tagged.tex}

\input{fig/col-vs-surf.tex}

\subsection{Surface Algorithm Benchmark}

\input{fig/benchmarking}

We performed benchmarking experiments to assess the computational performance of our new surface-based algorithms.
Due to limited completed implementations of compiled-language algorithms, we performed the bulk of benchmarking using the Python implementations.
While Python is an interpreted language and the Python-implemented algorithms weren't specifically implemented to maximize performance, and has an intrinsic performance penalty due to that, the algorithms were all in the same footing and we use the ``optimize''' flag to strip assert statements out of the benchmarks.
However, in the process of porting the tilted surface algorithm over to Cerebras Software Language we did create an implementation of that algorithm in Zig which is a compiled language and is capable of compiler optimizations.
We augment the Python with a benchmark of this algorithm.
Figure \ref{fig:benchmarking} provides an overview of results.

% https://github.com/mmore500/hstrat-surface-concept/blob/51d636d768d474fc5148b9fcaa199c1b7776e915/benchmark.ipynb
We found that the Python implementations of the surface tilted and steady algorithms both took around 4,200ns per operation (SEM c. 50; $n=20$).
For context, this was about $4\times$ the measured time for a surface placement using a trivial calculation (SEM c. 0.05; $n=20$).
The column implementations of steady and tilted fared much worse, taking about $7\times$ and $34\times$ the execution time per operation compared to the surface operations.
Mann-Whitney U tests confirmed that surface implemnetations significantly outperformed their column counterparts. (Figure \ref{fig:benchmarking}).

% https://github.com/mmore500/wse-sketches/blob/d4ab0155f63ff5809f8eeca1169ad9b272c30a68/binder/benchmark.ipynb
Zig implementation of tilted surface:
233 ns per operation (SEM 0.9; $n=20$).
This was $47\times$ the measured time for a trivial placement calculation (SEM 0.2; $n=20$).
For context, this time a little more than twice the amount of time required for a main memory access in contemporary computing hardware \citep{markus2022memory}.
